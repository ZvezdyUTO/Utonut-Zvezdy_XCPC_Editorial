# A Balanced Problemset?

所有者: Zvezdy
标签: 数学
创建时间: 2024年3月3日 12:39

设 $n$ 个子问题的难度为 $a_1,a_2,a_3,\ldots,a_n$ 。

根据 GCD 的性质，

 $GCD(a_1,a_2,a_3,\ldots,a_n)$= $GCD(a_1,a_1+a_2,a_1+a_2+a_3,\ldots,a_1+a_2+a_3+\ldots+a_n=x)$ 

> 这个性质可以通过数学归纳法来证明。
> 
> 
> 首先，对于 $n=2$ 的情况，即有a1和a2两个数。我们有：
> 
> $GCD(a_1, a_2) = GCD(a_1, a_1 + a_2)$
> 
> 这是因为，如果一个数能够同时整除a1和a2，那么它也能够整除a1和a1+a2，反之亦然。所以它们的最大公约数是相等的。
> 
> 接下来，假设对于任意的n=k时，上述性质成立，即：
> 
> $GCD(a_1,a_1+a_2,a_1+a_2+a_3,\ldots,a_1+a_2+a_3+\ldots+a_k)$ $GCD(a_1,a_2,a_3,\ldots,a_n)$
> 
> 我们来证明当 $n=k+1$ 时，性质也成立：
> 
> 对于 $n=k+1$ ，我们有：
> 
>  $GCD(a_1,a_2,a_3,\ldots,a_k,a_k+1) = GCD(GCD(a_1,a_2,a_3,\ldots,a_k),a_k+1)$ 
> 
> 根据我们的假设，
> 
> $GCD(a_1, a_2, ..., a_k) = GCD(a_1, a_1+a_2, a_1+a_2+a_3,...,a_1+a_2+...+a_k)$ ，
> 
> 所以我们可以将上式中的第一个参数替换为a1到ak之和：
> 
>  $=GCD(GCD(a_1, a_1+a_2, a_1+a_2+a_3, ..., a_1+a_2+...+a_k), a_k+1)=GCD(a_1, a_1+a_2, a_1+a_2+a_3, ..., a_1+a_2+...+a_k, a_k+1)$ 
> 
> 这就证明了性质在 $n=k+1$ 时也成立。
> 
> 综上所述，根据数学归纳法，对于任意的 $n$ ，该性质都成立。
> 

因此，最终答案总是 $x$ 的除数。

现在，考虑 $x$ 的除数 $d$ 。如果是 $n\cdot d\leq x$ ，则可以选择子问题的难度为 $d,d,d,\ldots,x-(n-1)d$ ，每个子问题的难度都是 $d$ 的倍数，因此，这个问题集的余数将是 $d$ 。否则，就不能选择难度为 $n$ 的子问题，使每个子问题的难度都是 $d$ 的倍数。

求这个条件成立的最大值 $d$ 。这可以在 $\mathcal{O}(\sqrt{x})$ 中使用琐碎因式分解来实现。

> 琐碎因式分解是将一个数表示为它的所有素因数的乘积，并且对每个素因数的幂次进行展开，这样的过程也称为完全分解。而琐碎因式分解则是在这个过程中，将那些次数较低的素因数的乘积表示为一个整体，而不是展开成其幂次的形式。例如，对于数24，它的素因数分解是：$24 = 2^3 * 3^1$在琐碎因式分解中，我们可以将这个表示为：$24 = 2 * 2 * 2 * 3$这种分解方法把所有的次数为1的素因数全部展开了，而次数大于1的素因数则保留了其幂次的表示。
> 

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    int t; cin>>t;
    while(t--){
        int n,x; cin>>x>>n;
        int ans=1;
        for(int i=1;i*i<=x;++i){ //模拟到x的平方根即可
            if(x%i==0){ //假如当前数是x的因子，就判断因子数是否够n个
                if(x/i>=n)  ans=max(i,ans);
                if(x/(x/i)>=n)  ans=max(x/i,ans);
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
