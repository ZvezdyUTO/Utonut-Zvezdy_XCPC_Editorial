# Equalize

所有者: Zvezdy
标签: 双指针, 数学
创建时间: 2024年2月11日 20:53

首先考虑排序，这题中有一个关键的思路是，在题目给出的数组中，最大的数+1是我们所需要的最小标准数。但我们不需要先考虑我们的标准数是什么，我们只知道我们拥有1~n的数可以用于填补题目给出的数组。最极端的情况就是给最小的数填上n，最大的数填上1，这时**最大数-最小数=n-1.**

        这时候就可以考虑这么一种可能，那就是如果两个数之差小于n，那么我们都可以从1~n中拿出数来补，但考虑题目要求1~n中的每个数我们只能取一次，我们就需要对数组去重。最后用同起点的双指针遍历，由于我们已经把数组从小到大排序且去重，所以很快就能找到一个最长的区间，区间中**最大数-最小数<n。**并且由于我们已经对数组进行去重，所以能保证我们所抽出的数是唯一的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200001],b[200001];
int main(){
    int T;cin>>T;
    while(T--){
        int n;cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        sort(a+1,a+1+n);

        int j=1;
        for(int i=1;i<=n;i++){
            if(a[i]!=a[i-1])
            b[j++]=a[i];
        }
去重操作，利用后缀运算符的性质。

        int ans=-1;
        int p=1,q=1;
        while(q<j){
            if(b[q]-b[p]<n)
                q++;
            else{
                ans=max(ans,q-p);
                p++;
            }
            if(q>=j)
            ans=max(ans,q-p);
        }
        cout<<ans<<endl;
    }
}
```