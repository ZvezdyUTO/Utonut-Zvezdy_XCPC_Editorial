# Vampiric Powers, anyone?

所有者: Zvezdy
标签: 位运算, 前缀和&差分
创建时间: 2024年1月8日 02:41

**题目大意：给出一堆数据，你可以选择将第n个到最后一个数进行异或运算来生成一个新的数尾接于原数组，你可以无限次进行这个操作直到生成一个最大的数。求那个最大的数。**

        很显然，这题需要使用关于异或运算的性质。即：a XOR b XOR b = a ,那么不难推出我们可以取任意一段连续的子序列来新生成数据。而异或运算的可逆性以及这个题目数据量→所有出现的数最大为 $2^8$ 那么我们可以枚举这些数据。

        我们一边算数据的前缀异或，一边将得出的结果记录在大小为 $2^8+1$ 的bool数组中，然后每次算出的前缀异或都拿来与bool数组中已经得出的结果再求异或：

        重点在这里！当看到最大的数字为2^8的时候，就可以发现这段数据比较小，就可能联想到暴力枚举！

*假如我们有 1 2 3 4 5 6，那么当我们拿 1 2 3 4 5 6的前缀异或和与 1 2 3 的前缀异或和进行异或的时候，我们就可以得出 4 5 6的异或和*

        请注意，必须是一边算前缀异或一边录入bool数组一边拿数组中的结果来求异或，不然不能保证求出的结果是由一个连续子序列异或出来的。

        尽管说生成新的数据就会有新的可能性，也就是新的组合，但只要我们将这些新生成的数拆开看做原本那些数的前缀异或和就好。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;scanf("%d",&n);
        int a[n+1],now_num=0,ans=0;
        bool b[256+1]={true};
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        for(int i=1;i<=n;i++){
            now_num^=a[i];
            b[now_num]=true;
            for(int j=0;j<=256;j++) if(b[j]) ans = max(ans, j^now_num);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

所以，当我们遇见连续子序列的运算处理，先考虑题目所给的运算方式有没有什么特殊之处（这题中表现为位运算的可逆性）最终大概率可以转化为前缀和处理的形式。请注意前缀和的一个重要的特性就是通过前缀和可以求出任意连续子序列的和。
