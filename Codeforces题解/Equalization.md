# Equalization

所有者: Zvezdy
标签: 位运算, 动态规划
创建时间: 2025年3月27日 16:02

很容易想到位运算，但这题明显又被位运算的贪心技巧坑了，鉴于这几天一直被数据范围坑，强烈建议以后看题先读数据范围，然后根据数据范围想猜一个最暴力最可靠的解法。时刻注意这种位运算/2的复杂度就是log，具体来看就可以粗略估计为60，那么操作这两个数的代价也就是60*60，完全是可以打出状态暴力枚举实现的。

再看操作的特点，实际上可以看出来是一个互斥背包，而且60*60没理由不打dp暴力转移，转移方程就是f[i][j]=min(f[i-(1<<?)][j], f[i][j-(1<<?)])+(1<<?) ?→Z，按格子来说，就是从自己的左上方元素们进行转移，鉴于减少的这个部分必须是独特的，因此，还得仔细考虑这里。

只要从循环上下手，自然就可以减少这些讨论量，为了保证我们的增加值独特且唯一，考虑最外层循环对增加值进行枚举，所以我们每次枚举的时候使用的增加值一定严格不超过当前增加值，另外就是内层循环的问题，因为我们依赖的是左上方的格子，因此当前转移必须是从后往前推导的，这样不会出现同层重复转移的情况。

```cpp
/*
 *  ██╗   ██╗████████╗ ██████╗ ███╗   ██╗██╗   ██╗████████╗
 *  ██║   ██║╚══██╔══╝██╔═══██╗████╗  ██║██║   ██║╚══██╔══╝
 *  ██║   ██║   ██║   ██║   ██║██╔██╗ ██║██║   ██║   ██║
 *  ██║   ██║   ██║   ██║   ██║██║╚██╗██║██║   ██║   ██║
 *  ╚██████╔╝   ██║   ╚██████╔╝██║ ╚████║╚██████╔╝   ██║
 *   ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝    ╚═╝
 *
 *  ███████╗██╗   ██╗███████╗███████╗██████╗ ██╗   ██╗
 *  ╚══███╔╝██║   ██║██╔════╝╚══███╔╝██╔══██╗╚██╗ ██╔╝
 *    ███╔╝ ██║   ██║█████╗    ███╔╝ ██║  ██║ ╚████╔╝
 *   ███╔╝  ╚██╗ ██╔╝██╔══╝   ███╔╝  ██║  ██║  ╚██╔╝
 *  ███████╗ ╚████╔╝ ███████╗███████╗██████╔╝   ██║
 *  ╚══════╝  ╚═══╝  ╚══════╝╚══════╝╚═════╝    ╚═╝
 */
// #pragma GCC optimize(2)
// #pragma GCC optimize(3,"Ofast","inline")
#include <bits/stdc++.h>
using ll = long long;
#define int ll
#define debug(x) std::cout << #x << " = " << x << '\n'

int f[65][65];

void Main_work() {
    int a, b;
    std::cin >> a >> b;
    int ans = 1e18;
    for (int i = 0; i <= 60; ++i) {
        for (int j = 0; j <= 60; ++j) {
            if ((a >> i) == (b >> j)) {
                ans = std::min(ans, f[i][j]);
            }
        }
    }
    std::cout << ans << '\n';
}

void init() {
    for (int i = 0; i <= 60; ++i) {
        for (int j = 0; j <= 60; ++j) {
            f[i][j] = 1e18;
        }
    }
    f[0][0] = 0;

    for (int k = 1; k <= 60; ++k) {
        for (int i = 60; i >= 0; --i) {
            for (int j = 60; j >= 0; --j) {
                if (i >= k) f[i][j] = std::min(f[i - k][j] + (1ll << k), f[i][j]);
                if (j >= k) f[i][j] = std::min(f[i][j - k] + (1ll << k), f[i][j]);
            }
        }
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0), std::cout.tie(0);
    // freopen("test.in", "r", stdin);
    // freopen("test.out", "w", stdout);
    init();
    int Zvezdy = 1;
    std::cin >> Zvezdy;
    while (Zvezdy--) {
        Main_work();
    }
    return 0;
}
```