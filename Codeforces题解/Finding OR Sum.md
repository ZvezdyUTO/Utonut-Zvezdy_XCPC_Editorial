# Finding OR Sum

所有者: Zvezdy
标签: 位运算
创建时间: 2025年3月18日 21:06

其实是一道不错的位运算思维题，从组合的角度重新理解了拆位与加法的关系。首先两个二进制数相加，可以看作是按位相加，进位，以及从低位往高位进位，正是因为有低位往高位进位的原因，不同位之间会产生连锁的干扰反应，假设我们需要让这种干扰反应停止，就让低位进位不要影响到高位即可，而低位进位只会严格影响它的下一位，所以交叉严格消除可以让进位的影响停止。

如何消除这种影响？观察到两个数在相加之前会分别进行按位或的操作，按位或这个操作可以被另类地看作是用一个外来数的1去将原来数某些位置进行覆盖，之所以这么看是因为后续如果再减掉这个外来的数，原来的数那些被覆盖的地方就算是被剥离了，因此这套复合操作完全可以看作是剥离掉原来这个数的某些位。

而题目的两次询问，刚好就是用来构造一个101010和010101来进行这种操作。在消除位以后，就可以单独判断每一位是没有1，还是有一个1，或者有两个1并产生了进位，如此一来就能严格构造出有相同作用的x和y，无法精确还原是因为有一个1的时候不知道是给x还是给y，但是在我们最终的运算中这并不重要，重要的是保证x和y中有一个存在这一位有1。

```cpp
/*
 *  ██╗   ██╗████████╗ ██████╗ ███╗   ██╗██╗   ██╗████████╗
 *  ██║   ██║╚══██╔══╝██╔═══██╗████╗  ██║██║   ██║╚══██╔══╝
 *  ██║   ██║   ██║   ██║   ██║██╔██╗ ██║██║   ██║   ██║
 *  ██║   ██║   ██║   ██║   ██║██║╚██╗██║██║   ██║   ██║
 *  ╚██████╔╝   ██║   ╚██████╔╝██║ ╚████║╚██████╔╝   ██║
 *   ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝    ╚═╝
 *
 *  ███████╗██╗   ██╗███████╗███████╗██████╗ ██╗   ██╗
 *  ╚══███╔╝██║   ██║██╔════╝╚══███╔╝██╔══██╗╚██╗ ██╔╝
 *    ███╔╝ ██║   ██║█████╗    ███╔╝ ██║  ██║ ╚████╔╝
 *   ███╔╝  ╚██╗ ██╔╝██╔══╝   ███╔╝  ██║  ██║  ╚██╔╝
 *  ███████╗ ╚████╔╝ ███████╗███████╗██████╔╝   ██║
 *  ╚══════╝  ╚═══╝  ╚══════╝╚══════╝╚═════╝    ╚═╝
 */
// #pragma GCC optimize(2)
// #pragma GCC optimize(3,"Ofast","inline")
#include <bits/stdc++.h>
using ll = long long;
#define int ll
#define debug(x) std::cout << #x << " = " << x << '\n'

void Main_work() {
    int obb = 0, even = 0;
    for (int i = 0; i < 30; i += 2) obb += (1ll << i);
    for (int i = 1; i < 30; i += 2) even += (1ll << i);
    int test_ev, test_ob;
    std::cout << obb << std::endl;
    std::cin >> test_ev;
    test_ev -= 2ll * obb;
    std::cout << even << std::endl;
    std::cin >> test_ob;
    test_ob -= 2ll * even;

    int x = 0, y = 0;
    for (int i = 0; i < 30; i += 2) {
        if (test_ob & (1ll << i)) x += (1ll << i);
        if (test_ob & (1ll << (i + 1))) x += (1ll << i), y += (1ll << i);
    }
    for (int i = 1; i < 30; i += 2) {
        if (test_ev & (1ll << i)) x += (1ll << i);
        if (test_ev & (1ll << (i + 1))) x += (1ll << i), y += (1ll << i);
    }

    std::cout << "!" << std::endl;

    int m;
    std::cin >> m;
    std::cout << (m | x) + (m | y) << std::endl;
}

void init() {
}

signed main() {
    // std::ios::sync_with_stdio(false);
    // std::cin.tie(0), std::cout.tie(0);
    // freopen("test.in", "r", stdin);
    // freopen("test.out", "w", stdout);
    init();
    int Zvezdy = 1;
    std::cin >> Zvezdy;
    while (Zvezdy--) {
        Main_work();
    }
    return 0;
}
```