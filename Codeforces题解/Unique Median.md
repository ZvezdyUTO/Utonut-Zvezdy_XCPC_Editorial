# Unique Median

所有者: Zvezdy
标签: 双指针, 思维
创建时间: 2025年3月27日 16:01

或许很快发现，判断一个子数组是否合法是比较困难的，因为假如中位数的数量多起来那么计数就完全不方便了，所以考虑计数题的另一个技巧：正难则反，也就是补集思想。考虑不合法的子数组特征如何，这种子数组一定是偶数长度，并且两个中位数不同，两个中位数不同的特征就是排序后中间被劈开，换言之，一定有一般元素大于等于某个值。此时我们就需要考虑如何计算这种子数组的数量，我们需要找到一个锚点去统计它们，那自然就是我们的参考值了。

这题最难的应该是码力构建，首先对于我们执行的这个过程，是几层循环嵌套的，如何去嵌套我们的循环是非常关键的，观察到我们的每个步骤除了中位数不同，其它相同，我们完全可以让枚举参考值的这个过程放在外部循环，独立讨论它们，有效减少码量。同时为了满足我们根据参考值左右一致的平衡，可以考虑使用小于参考值是-1，大于等于参考值是1的方式进行统计，这样当两个严格相等的时候，我们自然能选中符合要求的偶数区间。为了注意选到的区间一定是包含参考值，所以我们使用快慢指针，当遍历到参考值的时候再往前滑动统计。

这种采用补集思想进行逆推容斥，还有1和-1平衡统计，计数时找到锚点进行推导，快慢指针锚定有效区间的技巧都非常重要。其实另外一些题解还有奇偶统计容器分开的做法，但比较麻烦。

```cpp
/*
 *  ██╗   ██╗████████╗ ██████╗ ███╗   ██╗██╗   ██╗████████╗
 *  ██║   ██║╚══██╔══╝██╔═══██╗████╗  ██║██║   ██║╚══██╔══╝
 *  ██║   ██║   ██║   ██║   ██║██╔██╗ ██║██║   ██║   ██║
 *  ██║   ██║   ██║   ██║   ██║██║╚██╗██║██║   ██║   ██║
 *  ╚██████╔╝   ██║   ╚██████╔╝██║ ╚████║╚██████╔╝   ██║
 *   ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝    ╚═╝
 *
 *  ███████╗██╗   ██╗███████╗███████╗██████╗ ██╗   ██╗
 *  ╚══███╔╝██║   ██║██╔════╝╚══███╔╝██╔══██╗╚██╗ ██╔╝
 *    ███╔╝ ██║   ██║█████╗    ███╔╝ ██║  ██║ ╚████╔╝
 *   ███╔╝  ╚██╗ ██╔╝██╔══╝   ███╔╝  ██║  ██║  ╚██╔╝
 *  ███████╗ ╚████╔╝ ███████╗███████╗██████╔╝   ██║
 *  ╚══════╝  ╚═══╝  ╚══════╝╚══════╝╚═════╝    ╚═╝
 */
// #pragma GCC optimize(2)
// #pragma GCC optimize(3,"Ofast","inline")
#include <bits/stdc++.h>
using ll = long long;
#define int ll
#define debug(x) std::cout << #x << " = " << x << '\n'

void Main_work() {
    int n;
    std::cin >> n;
    std::vector<int> arr(n + 1);
    for (int i = 1; i <= n; ++i) std::cin >> arr[i];

    int ans = n * (n + 1) / 2ll;
    for (int num = 1; num <= 10; ++num) {
        std::vector<int> cur(n + 2);
        int lst = n + 1;
        std::map<int, int> bad;
        for (int i = n; i >= 1; --i) {
            cur[i] = cur[i + 1] + (arr[i] <= num ? 1 : -1);
            if (arr[i] == num) {
                while (lst > i) {
                    ++bad[cur[lst]];
                    --lst;
                }
            }
            if (bad.count(cur[i])) ans -= bad[cur[i]];
        }
    }

    std::cout << ans << '\n';
}

void init() {
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0), std::cout.tie(0);
    // freopen("test.in", "r", stdin);
    // freopen("test.out", "w", stdout);
    init();
    int Zvezdy = 1;
    std::cin >> Zvezdy;
    while (Zvezdy--) {
        Main_work();
    }
    return 0;
}

```