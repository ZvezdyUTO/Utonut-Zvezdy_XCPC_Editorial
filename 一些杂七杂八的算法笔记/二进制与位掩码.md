# 二进制与位掩码

所有者: Zvezdy
上次编辑时间: 2024年3月9日 11:23
创建时间: 2024年1月16日 16:10

二进制负数表达：其正数表达-1再取反。而判断一个二进制数是几则是先看首位是否为1（为1是负数），是负数则取反后+1变正数。用二进制表示带符号数时，非负部分与负数部分元素数量一样，而非负部分需要多被占用个0。

        定义二进制数：0b开头，十六进制：0x开头

二进制分成四位四位来看就是十六进制。同理八进制就是三位三位来看。

| 位运算 |    | |  & |   ^ |   ~ |  << |  >> |      >>> |
| --- | --- | --- | --- | --- | --- | --- | --- |
| >_< |  与 |  或 | 异或 | 取反 | 左移 | 右移 | 无符号移动 |
- 知识运用
    
    任何数取反+1即为它的相反数。但注意，最小的那个负数的相反数是得不到的，其取了相反数还是自己。
    
    根据加法的逻辑来看，因为计算机经常出现计算上有溢出，所以我们需要自己检查是否溢出。
    
    在含符号位的移动中，右移一律补符号位，左移统一补0。无符号移动除外。
    
    用左移右移实现乘以2的n次方运算，只对非负数有用。
    
    打印一个二进制数：运用左移和与运算，将1<<?个单位然后逐个用&匹配。
    

## 1. 子集生成

位掩码可以用来生成一个集合的所有子集。例如，如果我们有一个集合 `{1, 2, 3}`，我们可以使用位掩码来生成它的所有子集。以下是一个简单的 C++ 代码示例：

```cpp
#include <vector>#include <iostream>void generate_subsets(std::vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < (1 << n); ++i) {
        for (int j = 0; j < n; ++j) {
            if (i & (1 << j)) {
                std::cout << nums[j] << ' ';
            }
        }
        std::cout << '\n';
    }
}

int main() {
    std::vector<int> nums = {1, 2, 3};
    generate_subsets(nums);
    return 0;
}

```

这段代码首先计算出集合的大小 `n`，然后遍历从 `0` 到 `2^n` 的所有数字。对于每个数字，它将其视为一个位掩码，并根据位掩码中的 ‘1’ 生成子集。

## 2. 快速幂运算

位运算也可以用来进行快速幂运算。以下是一个简单的 C++ 代码示例：

```cpp
#include <iostream>long long fast_power(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {
            result *= base;
        }
        base *= base;
        power >>= 1;
    }
    return result;
}

int main() {
    std::cout << fast_power(2, 10) << std::endl;
    return 0;
}

```

这段代码使用了位运算来实现快速幂运算。它首先初始化结果为 1，然后在每次循环中，如果当前的幂是奇数（通过 `power & 1` 检查），那么就将当前的底数乘到结果中。然后，无论当前的幂是奇数还是偶数，都将底数平方，并将幂除以 2（通过 `power >>= 1` 实现）。这个过程一直持续到幂变为 0。