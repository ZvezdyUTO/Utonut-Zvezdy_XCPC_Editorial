# 动态规划

所有者: Zvezdy
上次编辑时间: 2024年8月26日 13:21
创建时间: 2024年1月23日 10:29

# 1.三大基本特征

---

### · 最优子结构

    一个大问题的最优解，一定包含小问题的最优解。所以我们可以借由推导子问题的最优解来得到大问题的最优解。

### · 重叠子问题

    既然大问题的最优解包含小问题的最优解，那么小问题的最优解在后续答案的求解中一定会被反复用到。而重叠子问题也正说明了该问题的优化思路，我们通过记录子问题的最优解避免重复地计算问题被重叠的部分。

### · 无后效性

    我们后续做出的抉择不会影响我们之前已做出抉择的结果，正因如此我们才可以肆无忌惮地使用子问题的最优解，在后续问题的求解中跳过子问题的求解过程。

-

# 2.状态转移方程

---

一般来说，都是由小往大算，然后看最新那个元素纳入进来行不行。要么包含最后一个元素，要么不包含，然后两种情况分别如何表示。

另外，背包实际上是一种策略，通常用来寻找某些元素组合后用于达成某种目标的选择策略，或者将它们选择过程中产生的累加贡献值进行求和（求方案数）。根据元素的数量，就可以分为01、完全、多重、分组背包，，每种都有各自的时间空间优化方式。

状态不一定设置为题目要求的最大直接价值，这个需要看题目而定，每次的思考模式都可以是看一个件元素选择或者不选择会造成如何结果，对于某种元素有不同的选择程度，如升级，那就可以看成01嵌套完全背包，或者分组背包来看待。

## 背包问题

### ① 01背包

    **给容量为 x 的背包，有 n 个重量为 wi，价值为 vi 的物品，问怎么装才能使包内物品总价值最高**

        我们需要一件一件物品地考虑是否将其装入。既然按这种思路，那么我们在考虑最新元素的时候就判断是否将第 i 件物品装入，接下来判断装入或者不装入如何去表示。

        可以用一个多维数组表示多情况叠加的状态：这里我们选择 f[i][j]，表示考虑前i件物品，且当前背包容量为 j 的情况。如果我们装入第 i 件物品，那么我们剩余的空间就为 [j-w[i]]，而在此状态下，我们的最优解可从 f[i-1][j-w[i]] 也就是考虑上一件物品的情况中获得。如果不装入第 i 件物品，那么我们当前的总价值为 f[i-1][j] ，这么处理就可以实现逐步考虑前 i 件物品的情况。 

```cpp
for(int i=1;i<=n;++i){
    for(int j=1;j<=ww;++j){
        if(j>=a[i].w)
            f[i][j]=max(f[i-1][j],f[i-1][j-a[i].w]+m[i].v);// 选择或者不选择
        else
            f[i][j]=f[i-1][j];//空间不足，不选择
    }
 }
```

### ②完全背包

    **相较于01背包，只是物品无限，随便装**

        我们在01背包的时候装和不装都是按之前那件物品考虑的，也就是说装的话就从不考虑这个物品的状态转移过来，而不装也就是不考虑当前物品的同容量状态。

       而对于这种情况，我们就只改变，如果装东西我们状态的变化情况即可，既然物品可以无限取，那么我们装物品的时候就不用从还没有考虑这个物品的那个状态来转移，而是在已经考虑这个物品的状态下进行转移。

```cpp
for(int i=1;i<=n;++i){
    for(int j=1;j<=ww;++j){
        if(j>=a[i].w)
            f[i][j]=max(f[i-1][j],f[i-1][j-a[i].w]+m[i].v);// 选择或者不选择
        else
            f[i][j]=f[i][j-1];//空间不足，不选择
    }
 }
```

### ③多重背包

 **每种物品既不是固定的一个也不是无数个** 

转化成01背包写，但是我们需要优化，比如：

### 二进制优化

原理：一个十进制的数转化为二进制，那么就是把n个物品分成 $2^0,2^1,2^2,2^3…2^?$ 个，然后直接01背包，便可以达到logN级的优化 

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=25000;

int N,V;
int w[maxn],v[maxn];
int dp[maxn];

int main() {
	cin>>N>>V;
	int cnt=0;
	for(int i=1; i<=N; i++) {
		int wi,vi,s; cin>>wi>>vi>>s;
		int k=1;		
		while(k<=s) {cnt++; w[cnt]=wi*k; v[cnt]=vi*k; s-=k;k*=2;}
		if(s>0) {cnt++; w[cnt]=wi*s; v[cnt]=vi*s;}
	}
	N=cnt;
	for(int i=1; i<=N; i++)
		for(int j=V; j>=w[i]; j--)
			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
	cout<<dp[V]<<endl;
	return 0;
}
 
/*
4 5
1 2 3
2 4 1
3 4 3
4 5 2
10
*/
```

### 还有一种优化：单调队列优化

假设我们有容量为7的背包，当前物品重量为2

那么我们只能从[j-2]处更新我们当前j的状态，比如1 3 5 7和2 4 6 8

于是我们按余数分组。假如当前物品无限量，那么我们就得在1 3 5 7里面找到最优方案，至于状态转移则是按照普通背包那样从[当前重量-放入物品重量]转移来

如果是多重背包，物品被限量了，那我们能转移的地方就很有限了，比如原来在7可以从1 3 5转移来，但现在只能从 3 5 转移来，以此类推，我们在5的时候只能从 1 3 转移过来，于是变成滑动窗口问题，想到采用单调队列优化求解。

实际在当前层的更新中，我们只是维持了一个 x*v,(x-1)*v,…,0*v的叠加需求，实际上影响我们最终更新状态的，是上一层的值，我们需要从上一层继承。并且随着窗口的滑动，前面胜出的值只会越来越大，直到它被踢出窗口。

因此得出状态转移方程：`d[i][j]=max(dp[i-1][x]+(y-x)/w[i]*v[i],dp[i-1][y])` 左边的是从单调队列首继承，右边的是直接从上一个物品继承。

那么我们该如何更新队列呢？单调队列当然只和同层的比较，我们每次让窗口滑动，都会改变当前所有元素的值，尤其是后面的会增加。但如果当前继承都比上一个在递增后大，那之前那个就永远不可能比现在这个新元素大了，这就是单调队列的淘汰。

比较的方式：`dp[i-1][j]`与`dp[i-1][队列尾]+(j-队列尾)/w[i]*v[i]`比大小。比得过就把之前的弹了，比不过就老老实实尾接在后面，如果相同，就把前面的弹掉，因为越前面越早过期。

别忘了清除过期元素以及在运行完一次后初始化队列！

### ④混合背包

其实就是完全和多重的混合，按照物品来看，物品无限的那一层就按完全背包写，多重的那一层就按单调队列优化写。某些时候即使题目说了是多重背包，但假如某个物品的数量已经达到了可取的极限，那它还是可以看作完全背包的。

## 从记忆化搜索到状态状态转移方程

试想回文字符串构建的那个例子，我们从最大的字符串开始，往中间递归函数，直到尽头，最后回推回来。在创建记忆化缓存区的时候就可以作为后期的dp表。有了dp表，那我们自然不需要递归了，可以直接从这张dp表推导状态转移方程。从状态转移方程的位置依赖关系得出dp求解的顺序。

# 3.区间动态规划

区间动态规划用于解决存在位置依赖关系的题目，在这类题目中都是讲一个大范围的问题拆成若干小范围问题来求解，所以将其称之为区间动态规划。对于此类问题最好是采用最优答案递推到最优子问题的思考方式去想如何写出递归的记忆化搜索，然后根据缓存表以及记忆化搜索更新的方式来打出用于递推的DP表。而讨论可能性展开一般有两种方式：基于两侧端点讨论的可能性展开，和基于范围上划分点的可能性展开。

### 变为回文串的最小插入次数：

很容易思考出状态：即让一个区间变为回文的最小插入次数，思考一下如何从小到大构造出一个回文串，那肯定是从中心开始，每次都在两边补上相同的字符。在这题中我们不知道哪个为中心最好，但我们可以从两端开始往中间递推，如果两端字符相同，那就不用管两端这个字符了，只要继续向中间推进，直到中间串变为回文。那么base case是什么，自然是只有1个字符和只有2个字符的时候，只有一个字符它天然就是回文，只有两个字符的时候如果它们相等就不用管，不相等则需要补1使其变为回文。

由此缓存表可以推导出dp表，发现如果左右不等，则依赖 l-1 , r 和 l , r-1 的答案，如果左右相等，则依赖 l-1 , r-1 位置的字符串。选择从下往上递推，从左往右递推，求解答案。

### 只能拿最外侧元素的零和博弈

零和博弈的一个性质就是让对手尽可能分少就等于我拿到了最多的分，在这题的递归中这个道理依然适用。每一步的选择就只有选左和选右这两个分支，然后下一层就是另一名玩家行动，所以一定是留更小的那个给下一名玩家。在递推中实现则是，看玩家1拿走左边元素还是右边元素，每种选择都对应着两种对手方案，拿左和拿右，所以下一层递归是从  l+2,r   l+1,r+1   l,r-2   开始的。实际上这么讨论就是从玩家2的角度来多预测一个玩家1的选择，这三个里面选最小也是因为我们有一个讨论玩家1取左、取右的判断。如此向内侧推导base case，只剩1个元素的时候，肯定直接拿，只剩2个元素的时候，就拿大的，在搜索的时候加条件判断即可。将记忆化搜索转为DP的方式也很简单，可以发现位置依赖的关系是[l+2][r] , [l+1][r-1] , [l][r-2]。

### 多边形拆三角形按积计算得分

题目的一个特殊条件，三角形的边不能有交叉实际上就是为了能让这题成为一道实际的“区间划分题目”。设想一下将一个多边形划分为多个没有边相交的三角形的情景：选择一条起始点划分后，继续以某区间左右端点为顶点，找到另外一个点连线继续划分。BaseCase就是相同点和相邻点返回0，不然就分割。

然后依旧是打dp表，可以发现分割关系的区间dp需要三重循环，是根据 l,k  k,r 来制作第三层循环，也就是枚举分割点位置。

### 找出特定顺序切木棍使答案最小

先思考记忆化搜索的版本，我们考虑从一个位置下刀后它的代价就是此时的 l~r 长度，而我们切割后又会得出两个子区间，在这两个子区间中继续递归求解就行。然后根据此缓存表思考dp数组的实现方式，模拟后发现依旧是老样子的n^3枚举断点，从下往上从左往右推。

### 打气球，每次得分按左中右之积计算

开始尝试讨论先打爆哪个气球，后面发现实际上是不妥的，因为在枚举左半边的时候不知道右半边没爆的气球是哪个，而每次枚举状态的时候其实是需要保证当前尝试一定能得到准确结果的。所以将其倒序进行，也就是枚举哪个气球最后爆炸，那么这时候计算贡献值就是和木棍那题一样看左边界和右边界了。特判边界条件的时候就单独把最先打爆左气球和最先打爆右气球拿出来判一下。

再来看这个转换成区间dp，依旧是区间分割的那一套，不一样的是因为存在乘积所以要特判边界，因为边界外的内容不需要用加法累进来。在跑中间的循环前写在前面就好。

### 看有多少种添加括号的方案能让bool运算式子变为理想结果

依旧一样，就按最后将哪个符号用于运算就好，因为是求方案数，所以dp数组里面存的就是某个区间变为0/1的方案数，因为任何运算在括号不限的情况下都可以被拆解为符合左边/右边的结合。递归函数可以选择返回一个数组，代表这个区间变0的方案数和变1的方案数，然后乘法原理秒了。

### 消消乐，一次消的越多得分越多

有一种特殊的处理信息的方式，就是利用“前缀和”，标记当前这个位置上的前面有几个跟它一样相同的小球，这样讨论就可以

# 4.树形动态规划

树形DP其实依赖关系很简单，基本都是根依赖叶子的信息。邻接表拿递归遍历，就可以用于PK信息或者累加元素。

### 在二叉树中分配硬币

涉及到了关于树中计数的问题，总结一下这些数学知识总归是有利的，想象一下一开始所有的k枚硬币都在根节点，那么第一层一定是左右各移动了(k-1)/2次,然后以此类推下去，直到叶子，叶子就是移动了一次。如果把硬币都拆散来看，那么就是有些硬币是从头走到底，而有的走到中途就行。

再以树的递归来思考这题的计数方式，那么就是每个子树的移动次数都要一层一层累加上来，直到遇到源头，也就是有硬币存在的地方，那么就消除空位影响，也就是拿那半边的硬币数和总位置数作差然后求绝对值。

### 路径总和III

有一些TIPS，之前说树形DP一半是父节点向子节点要信息，当然也可以是子节点向父节点要信息，在这题中可以发现如果向下走会有岔路，但是往回退的路径绝对唯一，所以最好的方式是计算以？为终点的情况下，有多少条合法路径。

DFN序：实际上就是dfs序，但是如果在求出dfn序的同时求出每个节点的子节点,，就可以拿到囊括关系。因为在dfn序数组中，某个元素往后 x（x是其拥有的子树大小）个位置都是它的子树。当然请注意，DFN序不像DFS序那样囊括着回溯的顺序。