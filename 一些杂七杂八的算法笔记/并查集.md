# 并查集

所有者: Zvezdy
Sub-页面中: 最小生成树-Kruskal算法 (%E5%B9%B6%E6%9F%A5%E9%9B%86%20e80047843f694684ad5fcb087aeca6b9/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Kruskal%E7%AE%97%E6%B3%95%2055c7adda5efa4ce3b77ed290a9d11a07.md)
上次编辑时间: 2024年4月25日 23:13
创建时间: 2024年1月17日 13:02

意思是：不相交集合

常见操作：合并、查找

核心操作：判断一个元素是否为祖先

**并查集的表示方式：**

**①用数组下标表示元素，用数组内容表示其属于哪个集合。**查找方便，合并麻烦。

**②用树状结构表示并查集。用数组下标表示元素，数组内容表示元素的父节点，父节点与自己相同的则为根节点。**查找稍慢，但是合并快，且更符合现实情况。

我们默认总是使用第二种树状结构表示并查集，那么最坏的查找情况为该树层数最多。为了让这棵树没有那么高，我们合并的时候一般选择将低的树合并到高的树中。不过一般来说不用这么写。

```cpp
int findboss(int x){
    int jump=x;
    while(bing[jump]!=jump)//直到自己的上级为自己才算祖先
        jump=bing[jump];
    return jump;
}
```

```cpp
void mix(int x,int y){
    int fx=findboss(x),fy=findboss(y);
    if(fx!=fy)    bing[fx]=fy;//只需要保证两边都有同一个祖先就行。
}
```

每输入一套数据就合并一次，以此建立并查集。

### 实际运用:

[最小生成树-Kruskal算法](%E5%B9%B6%E6%9F%A5%E9%9B%86%20e80047843f694684ad5fcb087aeca6b9/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Kruskal%E7%AE%97%E6%B3%95%2055c7adda5efa4ce3b77ed290a9d11a07.md)

理论基础：MST性质（至少存在一个最小生成树包含最短这条边）

步骤：将原始图的n个节点看成n个独立的子图，每次选取当前最短的边查看这两个图是否是完全不同的两个子图，如果是则加入该边，否则看下一个最短的边。选取完n-1条边后结束程序。

判断子图是否不同即为判断加入边后是否构成回路⇒看两个即将被合并的子图的根是否相同。

为了排序方便，使用结构体来存储节点以及节点链接边的权值。