# Subarrays with K Different Integers

所有者: Zvezdy
标签: 思维, 滑动窗口
创建时间: 2024年7月30日 21:32

连续区间算是滑动窗口的一个特征了，滑动窗口有一个比较重要的trick就是，窗口大小可能会和某种单调性有关，在这一题中，窗口开的越大，那么我们所选取的这一段区间中 不同数字的个数就越多。滑动窗口中比较重要的就是左指针以及右指针，如果要求的是不同数字个数小于等于k的区间个数，那么当我们右指针走到某个点上时，此终点能够提供的最大贡献就是 (r-最左边的合法i)，所以我们可以轻松求出整个数组中不同数字小于等于k的区间个数。我们可以使用容斥原理，求出不同数字个数小于等于k的区间个数以及不同数字个数小于等于k-1的区间个数，再相减就是我们所需的答案。

```cpp
/* ★ _____                           _         ★*/
/* ★|__  / __   __   ___   ____   __| |  _   _ ★*/
/* ★  / /  \ \ / /  / _ \ |_  /  / _  | | | | |★*/
/* ★ / /_   \ V /  |  __/  / /  | (_| | | |_| |★*/
/* ★/____|   \_/    \___| /___|  \__._|  \__, |★*/
/* ★                                     |___/ ★*/
#include <bits/stdc++.h>
using namespace std;
#define debug(x) cout << #x << " = " << x << endl

int main() {
    // 包信息：—————————————————————————————————————————————————————————————
    vector<int> nums;
    int k;
    // 测试用例:
    nums = {1, 2, 1, 2, 3};
    k = 2;
    // 主程序：—————————————————————————————————————————————————————————————
    auto SolveProblem = [&]() {
        int n = nums.size();
        auto f = [&](int t) {
            int dif = 0;
            int res = 0;
            unordered_map<int, int> mp;
            for (int i = 0, j = 0; j < n; ++j) {
                if (++mp[nums[j]] == 1) {
                    ++dif;
                }
                while (dif > t) {
                    if (--mp[nums[i]] == 0) {
                        --dif;
                    }
                    ++i;
                }
                res += j - i + 1;
            }
            return res;
        };
        return f(k) - f(k - 1);
    };
    // 调试输出：———————————————————————————————————————————————————————————
    auto ans = SolveProblem();
    cout << ans;
    return 0;
}
```
