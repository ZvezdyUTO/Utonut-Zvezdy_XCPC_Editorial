# Trapping Rain Water

所有者: Zvezdy
标签: 双指针
创建时间: 2024年7月31日 10:49

应该是典的不能再典的题目了。这题最重要的分析应该是每个格子所能接到的雨水量和它左右两边的最大高度有关。所以一种朴素的做法就是预处理出每一个点左右两边的最大高度，然后遍历点累加答案，复杂度为O(n)。

但是实际上辅助数组以及时间还可以进一步被优化。我们从左右两端向中间遍历，与此同时维护一个左侧最大值以及右侧最大值，想象一下我们来到了某个格子，此时我们有左侧最大值以及右侧最大值，如果目前的左侧最大值比右侧最大值还小，那么我们这个各自一定只能装lmax-height[i]的雨水。因为lmax对于l指针来说绝对真实。为了维持这种局面，我们考虑左右谁小就将谁的贡献累入答案中，并移动其指针。

再接着深挖这个问题，我们在想朴素解法的判断时，所需要的是左边最大值和右边最大值，那么如果我们知道右边某处最大值已经比我们当前左侧真实最大值大了，那么即使我们右侧选择部分并不完全，也可以用左侧的数值求出答案，这也是一种单调性。那么我们为了维护这种永远有个小的数值的局面，我们就选择只移动数值小的那一侧指针。

```cpp
/* ★ _____                           _         ★*/
/* ★|__  / __   __   ___   ____   __| |  _   _ ★*/
/* ★  / /  \ \ / /  / _ \ |_  /  / _  | | | | |★*/
/* ★ / /_   \ V /  |  __/  / /  | (_| | | |_| |★*/
/* ★/____|   \_/    \___| /___|  \__._|  \__, |★*/
/* ★                                     |___/ ★*/
#include <bits/stdc++.h>
using namespace std;
#define debug(x) cout << #x << " = " << x << endl

int main() {
    // 包信息：—————————————————————————————————————————————————————————————
    vector<int> height;
    // 测试用例:
    height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
    // 主程序：—————————————————————————————————————————————————————————————
    auto SolveProblem = [&]() {
        int n = height.size();
        int ans = 0;
        int l = 0, r = n - 1;
        int lmax = 0, rmax = 0;
        while (l < r) {
            lmax = max(lmax, height[l]);
            rmax = max(rmax, height[r]);
            if (lmax < rmax) {
                ans += lmax - height[l];
                ++l;
            } else {
                ans += rmax - height[r];
                --r;
            }
        }
        // debug(ans);
        return ans;
    };
    // 执行指令：———————————————————————————————————————————————————————————
    SolveProblem();
    return 0;
}
```