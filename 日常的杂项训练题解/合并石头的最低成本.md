# 合并石头的最低成本

所有者: Zvezdy
标签: 区间动态规划
创建时间: 2024年6月8日 11:08

对于此类合并的题目，比较麻烦的就是每次合并都会改变整个数组，比移除更麻烦的是它的合并对于顺序更为苛刻，所以就不能单纯看成只从左往右或者只从右往左扫描，而是需要一个全新的视角

再来看这道题目的特殊条件，每次合并所需的堆数固定，且都是相邻。光是从每次合并所需的个数固定我们就可以以此来切割区间，比如我们每次都要拿k堆石子合成，那我们就可以看成是左边部分合成一堆，右边部分合成k-1堆，这是逆序推导而来的，因为最终就是只剩k堆石子，那我们左边合成完一堆了，右边肯定剩余k-1堆才能最后变为一堆。这也算是一种考虑到了如何枚举合并手段还有区间范围的方式了。

最后发现这实际上就是分割子串的区间dp，依旧是从下往上从左往右推，到最后其实可以发现如果从小往大的推根本不用关心我们当前区间被分成几份，因为每次合并都是削减固定长度，在总长度固定的情况下就一定最终被合成为一个单独的堆，所以状态就是某个区间的石子最终被合成为一堆的最小代价。

至于分割就是它左半边合成一堆的最小代价和右半边被合成为一堆的最小代价加上它本身的区间前缀和就好。每次枚举分割完后看看该区间是不是刚好能被合成，如果是就说明此处是作为一个合成材料的，需要加上区间前缀和。

```cpp
/* ★ _____                           _         ★*/
/* ★|__  / __   __   ___   ____   __| |  _   _ ★*/
/* ★  / /  \ \ / /  / _ \ |_  /  / _  | | | | |★*/
/* ★ / /_   \ V /  |  __/  / /  | (_| | | |_| |★*/
/* ★/____|   \_/    \___| /___|  \__._|  \__, |★*/
/* ★                                     |___/ ★*/
using namespace std;
const int MODE=19650827;
const int INF=0x7ffffff;
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n=stones.size();
        if((n-1)%(k-1)) return -1;
        int s[101]{0};
        for(int i=1;i<=n;++i){//前缀和数组
            s[i]=stones[i-1];
            s[i]+=s[i-1];
        }
        int dp[101][101]{0};
        for(int l=n-1;l>=1;--l)
            for(int r=l+1;r<=n;++r){
                int ans=INF;
                for(int i=l;i<r;i+=k-1)
                    ans=min(ans,dp[l][i]+dp[i+1][r]);
                if((r-l)%(k-1)==0) ans+=s[r]-s[l-1];
                dp[l][r]=ans;
            }
        return dp[1][n];
    }
};
```
