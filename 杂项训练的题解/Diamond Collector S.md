# Diamond Collector S

所有者: Zvezdy
标签: 动态规划, 双指针
创建时间: 2024年1月18日 14:27

**题目大意：给定n个数，要求求出两个不相交的区间，区间的最大数与最小数之差不能大于k，找两个元素最多的区间。**

        一般而言，看到这种情况多半都会想到先排列再用双指针求该数向左最长延伸的区间。不过如果如此操作遇到了不同的区间相交就没救了。但既然是求两个不同的区间，那么我们可以以当前数为分割点，求出该数左边所存在的最长的区间，和该数右边存在的最长的区间，可保证这两个区间不相交。最终求解出整个区域内最长的两个不相交区间。

        那么我们依然是用双指针的方式求解出一个数往左、往右延伸的最大区间（最好开两个循环分别求解）。接着利用动态规划不断更新成该数左边、右边所存在的最长区间，最后遍历一遍求出我们的答案即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[50000+1],f[50000+1],g[50000+2];
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    int l=1,r=n,ans=0;
    for(int i=1;i<=n;++i){
        if(a[i]-a[l]<=k)    f[i]=i-l+1;
        else{ 
            while(a[i]-a[l]>k)
                ++l;
            f[i]=i-l+1;
        }
        f[i]=max(f[i],f[i-1]);
    }
    for(int i=n;i>=1;--i){
        if(a[r]-a[i]<=k)    g[i]=r-i+1;
        else{ 
            while(a[r]-a[i]>k)
                --r;
            g[i]=r-i+1;
        }
        g[i]=max(g[i],g[i+1]);
    }
    if(n==1){printf("%d",f[1]);return 0;}
    for(int i=2;i<=n;++i){
        ans=max(ans,f[i-1]+g[i]);
    }
    printf("%d",ans);
    return 0;
}
```

        该题目的突破点在于如何保证找出的两个区间不相交，如果是一个完整的区间被分割成了两个小区间，那么可以保证不同小区间的子区间绝不相交。所以最后我们所要求的信息是：以当前数为分割点，该数左侧所存在的最长区间，和该数+1右侧所存在的最长区间。

        其中双指针的运用关键在于确定起点，若不符合条件则使用while循环更新指针起点往右，直到符合条件为止。