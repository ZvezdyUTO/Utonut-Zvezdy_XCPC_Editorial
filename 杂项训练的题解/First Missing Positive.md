# First Missing Positive

所有者: Zvezdy
标签: 双指针
创建时间: 2024年7月31日 14:09

刚好用来求mex，可能是mex的最好求法了。参考一下原来朴素的暴力哈希求mex的方法，我们都是打一个额外数组来点亮出现过的数字，第一个位置上出现空缺的数字就是我们所需的答案值。参考这个各回各家的方法，使用swap函数，我们是不是能在原数组上构造我们所需要的数组？

在一开始，我们的最好结果是数组上的每个位置都刚好被放满，那么我们所能拿到的最好值就是这个数组的长度。但如果出现了某些没办法拿的数字怎么办？比如说我们这个数组原长度是10，但此时出现了13，那么这个数就一定不能被使用上，我们现在需要考虑找个地方把它堆在那里废弃。因为我们出现了一个没有用的数，那么我们能够取到的mex值就会进一步变少，所以最好是堆在最右侧，然后我们打一个右指针代表数组长度-1，那么这道题的双指针做法就非常明显了：while(l < r)，最后取合法的l就好。

现在考虑有哪些情况会让我们的数字被废弃，默认我们l左边都是已经放好的数字，如果此时再出现一个数字比 l 小，或者发现本来我们当前数的正统位置已经有一个正确的数字了，但现在又出现一个相同的，那么就考虑废弃这个数。最后为了判断，每次都把我们当前发现的有用的数字swap到它们应该出现的位置上。

```cpp
/* ★ _____                           _         ★*/
/* ★|__  / __   __   ___   ____   __| |  _   _ ★*/
/* ★  / /  \ \ / /  / _ \ |_  /  / _  | | | | |★*/
/* ★ / /_   \ V /  |  __/  / /  | (_| | | |_| |★*/
/* ★/____|   \_/    \___| /___|  \__._|  \__, |★*/
/* ★                                     |___/ ★*/
#include <bits/stdc++.h>
using namespace std;
#define debug(x) cout << #x << " = " << x << endl

int main() {
    // 包信息：—————————————————————————————————————————————————————————————
    vector<int> nums;
    // 测试用例:
    nums = {-3, 2, 1, 8, 5, 4, 2, 3, 5, 13};
    // 主程序：—————————————————————————————————————————————————————————————
    auto SolveProblem = [&]() {
        int l = 0, r = nums.size();
        while (l < r) {
            if (nums[l] == l + 1) {
                ++l;
            } else if (nums[l] <= l || nums[l] > r || nums[nums[l] - 1] == nums[l]) {
                swap(nums[l], nums[--r]);
            } else {
                swap(nums[l], nums[nums[l] - 1]);
            }
        }
        // debug(r+1);
        return l + 1;
    };
    // 执行指令：———————————————————————————————————————————————————————————
    SolveProblem();
    return 0;
}

```