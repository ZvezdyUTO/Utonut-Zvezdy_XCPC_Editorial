# 小红不想做完全背包

所有者: Zvezdy
标签: 动态规划, 数学
创建时间: 2024年4月8日 20:00

实际上可以这么思考，几个数相加后是某个数的倍数可以看作是几个数相加后模那个数的余为零。

因此有关整除的问题其实都可以被看作是余数的处理。

如果按一般的思路来思考这些数相加后能被谁整除，那数的大小不同可构成太多种情况了，但我们实际上不需要考虑那个数本身是多少，我们只需要知道它模目标数的余为零就好。

于是我们可以构建一个一维DP数组来表示一些数相加后对目标数取模的余，构成那些余数最少需要几个数。最后只要我们取余为0的部分就可以完成该题。

实际上，最关键的状态转移方程为 `dp[(a[i]+j)%p]=min(dp[(a[i]+j)%p],dp[j]+1);`这代表着，a[i]+j的余数可以表示为 j 的余数加上一个a[i]。j 是按照1~p来遍历，这也运用了完全背包的思想以及混合了对余数的理解，因为按理来说一个数要弄上几倍来得到某个余数，顶破天也不可能超过这个余数。更何况在一开始我们就对这个数取模了。

```mermaid
for (int i = 1; i <= n; i++)
    cin >> a[i];
memset(dp, 0x3f, sizeof dp);
for (int i = 1; i <= n; i++){
    dp[a[i] % p] = min(dp[a[i] % p], 1ll);
    for (int j = 1; j <= p; j++)
        dp[(j + a[i]) % p] = min(dp[(j + a[i]) % p], dp[j] + 1);
}
```